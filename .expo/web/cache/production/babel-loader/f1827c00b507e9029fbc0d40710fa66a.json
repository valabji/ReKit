{"ast":null,"code":"import*as React from'react';import NavigationBuilderContext from\"./NavigationBuilderContext\";export default function useOnAction(_ref){var router=_ref.router,getState=_ref.getState,setState=_ref.setState,key=_ref.key,listeners=_ref.listeners,routerConfigOptions=_ref.routerConfigOptions;var _React$useContext=React.useContext(NavigationBuilderContext),onActionParent=_React$useContext.onAction,onRouteFocusParent=_React$useContext.onRouteFocus,addActionListenerParent=_React$useContext.addActionListener,trackAction=_React$useContext.trackAction;var routerConfigOptionsRef=React.useRef(routerConfigOptions);React.useEffect(function(){routerConfigOptionsRef.current=routerConfigOptions;});var onAction=React.useCallback(function(action){var visitedNavigators=arguments.length>1&&arguments[1]!==undefined?arguments[1]:new Set();var state=getState();if(visitedNavigators.has(state.key)){return false;}visitedNavigators.add(state.key);if(typeof action.target==='string'&&action.target!==state.key){return false;}var result=router.getStateForAction(state,action,routerConfigOptionsRef.current);result=result===null&&action.target===state.key?state:result;if(result!==null){trackAction(action);if(state!==result){setState(result);}if(onRouteFocusParent!==undefined){var shouldFocus=router.shouldActionChangeFocus(action);if(shouldFocus&&key!==undefined){onRouteFocusParent(key);}}return true;}if(onActionParent!==undefined){if(onActionParent(action,visitedNavigators)){return true;}}for(var i=listeners.length-1;i>=0;i--){var listener=listeners[i];if(listener(action,visitedNavigators)){return true;}}return false;},[getState,router,onActionParent,trackAction,onRouteFocusParent,setState,key,listeners]);React.useEffect(function(){return addActionListenerParent===null||addActionListenerParent===void 0?void 0:addActionListenerParent(onAction);},[addActionListenerParent,onAction]);return onAction;}","map":{"version":3,"sources":["useOnAction.tsx"],"names":["routerConfigOptions","onAction","onRouteFocus","addActionListener","trackAction","React","routerConfigOptionsRef","visitedNavigators","state","getState","action","result","router","setState","onRouteFocusParent","shouldFocus","key","onActionParent","i","listeners","listener","addActionListenerParent"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  NavigationAction,\n  NavigationState,\n  PartialState,\n  Router,\n  RouterConfigOptions,\n} from '@react-navigation/routers';\nimport NavigationBuilderContext, {\n  ChildActionListener,\n} from './NavigationBuilderContext';\n\ntype Options = {\n  router: Router<NavigationState, NavigationAction>;\n  key?: string;\n  getState: () => NavigationState;\n  setState: (state: NavigationState | PartialState<NavigationState>) => void;\n  listeners: ChildActionListener[];\n  routerConfigOptions: RouterConfigOptions;\n};\n\n/**\n * Hook to handle actions for a navigator, including state updates and bubbling.\n *\n * Bubbling an action is achieved in 2 ways:\n * 1. To bubble action to parent, we expose the action handler in context and then access the parent context\n * 2. To bubble action to child, child adds event listeners subscribing to actions from parent\n *\n * When the action handler handles as action, it returns `true`, otherwise `false`.\n */\nexport default function useOnAction({\n  router,\n  getState,\n  setState,\n  key,\n  listeners,\n  routerConfigOptions,\n}: Options) {\n  const {\n    onAction: onActionParent,\n    onRouteFocus: onRouteFocusParent,\n    addActionListener: addActionListenerParent,\n    trackAction,\n  } = React.useContext(NavigationBuilderContext);\n\n  const routerConfigOptionsRef = React.useRef<RouterConfigOptions>(\n    routerConfigOptions\n  );\n\n  React.useEffect(() => {\n    routerConfigOptionsRef.current = routerConfigOptions;\n  });\n\n  const onAction = React.useCallback(\n    (\n      action: NavigationAction,\n      visitedNavigators: Set<string> = new Set<string>()\n    ) => {\n      const state = getState();\n\n      // Since actions can bubble both up and down, they could come to the same navigator again\n      // We keep track of navigators which have already tried to handle the action and return if it's already visited\n      if (visitedNavigators.has(state.key)) {\n        return false;\n      }\n\n      visitedNavigators.add(state.key);\n\n      if (typeof action.target === 'string' && action.target !== state.key) {\n        return false;\n      }\n\n      let result = router.getStateForAction(\n        state,\n        action,\n        routerConfigOptionsRef.current\n      );\n\n      // If a target is specified and set to current navigator, the action shouldn't bubble\n      // So instead of `null`, we use the state object for such cases to signal that action was handled\n      result = result === null && action.target === state.key ? state : result;\n\n      if (result !== null) {\n        trackAction(action);\n\n        if (state !== result) {\n          setState(result);\n        }\n\n        if (onRouteFocusParent !== undefined) {\n          // Some actions such as `NAVIGATE` also want to bring the navigated route to focus in the whole tree\n          // This means we need to focus all of the parent navigators of this navigator as well\n          const shouldFocus = router.shouldActionChangeFocus(action);\n\n          if (shouldFocus && key !== undefined) {\n            onRouteFocusParent(key);\n          }\n        }\n\n        return true;\n      }\n\n      if (onActionParent !== undefined) {\n        // Bubble action to the parent if the current navigator didn't handle it\n        if (onActionParent(action, visitedNavigators)) {\n          return true;\n        }\n      }\n\n      // If the action wasn't handled by current navigator or a parent navigator, let children handle it\n      for (let i = listeners.length - 1; i >= 0; i--) {\n        const listener = listeners[i];\n\n        if (listener(action, visitedNavigators)) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    [\n      getState,\n      router,\n      onActionParent,\n      trackAction,\n      onRouteFocusParent,\n      setState,\n      key,\n      listeners,\n    ]\n  );\n\n  React.useEffect(() => addActionListenerParent?.(onAction), [\n    addActionListenerParent,\n    onAction,\n  ]);\n\n  return onAction;\n}\n"]},"metadata":{},"sourceType":"module"}