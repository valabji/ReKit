{"ast":null,"code":"import _regeneratorRuntime from\"@babel/runtime/regenerator\";import*as React from'react';import{getStateFromPath as getStateFromPathDefault,getPathFromState as getPathFromStateDefault,getActionFromState}from'@react-navigation/core';var getStateLength=function getStateLength(state){var length=0;if(state.history){length=state.history.length;}else{length=state.index+1;}var focusedState=state.routes[state.index].state;if(focusedState&&!focusedState.stale){length+=getStateLength(focusedState)-1;}return length;};var isUsingLinking=false;export default function useLinking(ref,_ref4){var config=_ref4.config,_ref4$getStateFromPat=_ref4.getStateFromPath,getStateFromPath=_ref4$getStateFromPat===void 0?getStateFromPathDefault:_ref4$getStateFromPat,_ref4$getPathFromStat=_ref4.getPathFromState,getPathFromState=_ref4$getPathFromStat===void 0?getPathFromStateDefault:_ref4$getPathFromStat;React.useEffect(function(){if(isUsingLinking){throw new Error(\"Looks like you are using 'useLinking' in multiple components. This is likely an error since URL integration should only be handled in one place to avoid conflicts. Also ensure that you set your android activity launchMode to single task in your AndroiManifest.xml file.\");}else{isUsingLinking=true;}return function(){isUsingLinking=false;};});var configRef=React.useRef(config);var getStateFromPathRef=React.useRef(getStateFromPath);var getPathFromStateRef=React.useRef(getPathFromState);React.useEffect(function(){configRef.current=config;getStateFromPathRef.current=getStateFromPath;getPathFromStateRef.current=getPathFromState;},[config,getPathFromState,getStateFromPath]);var getInitialState=React.useCallback(function _callee(){var path;return _regeneratorRuntime.async(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:path=location.pathname+location.search;if(!path){_context.next=5;break;}return _context.abrupt(\"return\",getStateFromPathRef.current(path,configRef.current));case 5:return _context.abrupt(\"return\",undefined);case 6:case\"end\":return _context.stop();}}},null,null,null,Promise);},[]);var previousStateLengthRef=React.useRef(undefined);var previousHistoryIndexRef=React.useRef(0);var pendingIndexChangeRef=React.useRef();var pendingStateUpdateRef=React.useRef(false);var pendingStateMultiUpdateRef=React.useRef(false);var numberOfIndicesAhead=React.useRef(0);React.useEffect(function(){window.addEventListener('popstate',function(){var _ref,_history$state;var navigation=ref.current;if(!navigation){return;}var previousHistoryIndex=previousHistoryIndexRef.current;var historyIndex=(_ref=(_history$state=history.state)===null||_history$state===void 0?void 0:_history$state.index)!==null&&_ref!==void 0?_ref:0;previousHistoryIndexRef.current=historyIndex;if(pendingIndexChangeRef.current===historyIndex){pendingIndexChangeRef.current=undefined;return;}var state=navigation.getRootState();var path=getPathFromStateRef.current(state,configRef.current);var canGoBack=true;var numberOfBacks=0;if(previousHistoryIndex===historyIndex){if(location.pathname+location.search!==path){pendingStateUpdateRef.current=true;history.replaceState({index:historyIndex},'',path);}}else if(previousHistoryIndex>historyIndex){numberOfBacks=previousHistoryIndex-historyIndex-numberOfIndicesAhead.current;if(numberOfBacks>0){pendingStateMultiUpdateRef.current=true;if(numberOfBacks>1){pendingStateMultiUpdateRef.current=true;}pendingStateUpdateRef.current=true;for(var i=0;i<numberOfBacks;i++){navigation.goBack();}}else{canGoBack=false;}}if(previousHistoryIndex<historyIndex||!canGoBack){if(canGoBack){numberOfIndicesAhead.current=historyIndex-previousHistoryIndex-1;}else{navigation.goBack();numberOfIndicesAhead.current-=previousHistoryIndex-historyIndex;}var _state=getStateFromPathRef.current(location.pathname+location.search,configRef.current);pendingStateMultiUpdateRef.current=true;if(_state){var action=getActionFromState(_state);pendingStateUpdateRef.current=true;if(action!==undefined){navigation.dispatch(action);}else{navigation.resetRoot(_state);}}}});},[ref]);React.useEffect(function(){var _ref$current;if(ref.current&&previousStateLengthRef.current===undefined){previousStateLengthRef.current=getStateLength(ref.current.getRootState());}if(ref.current&&location.pathname+location.search==='/'){var _ref2,_history$state2;history.replaceState({index:(_ref2=(_history$state2=history.state)===null||_history$state2===void 0?void 0:_history$state2.index)!==null&&_ref2!==void 0?_ref2:0},'',getPathFromStateRef.current(ref.current.getRootState(),configRef.current));}var unsubscribe=(_ref$current=ref.current)===null||_ref$current===void 0?void 0:_ref$current.addListener('state',function(){var _previousStateLengthR,_ref3,_history$state3;var navigation=ref.current;if(!navigation){return;}var state=navigation.getRootState();var path=getPathFromStateRef.current(state,configRef.current);var previousStateLength=(_previousStateLengthR=previousStateLengthRef.current)!==null&&_previousStateLengthR!==void 0?_previousStateLengthR:1;var stateLength=getStateLength(state);if(pendingStateMultiUpdateRef.current){if(location.pathname+location.search===path){pendingStateMultiUpdateRef.current=false;}else{return;}}previousStateLengthRef.current=stateLength;if(pendingStateUpdateRef.current&&location.pathname+location.search===path){pendingStateUpdateRef.current=false;return;}var index=(_ref3=(_history$state3=history.state)===null||_history$state3===void 0?void 0:_history$state3.index)!==null&&_ref3!==void 0?_ref3:0;if(previousStateLength===stateLength){if(location.pathname+location.search!==path){history.replaceState({index:index},'',path);previousHistoryIndexRef.current=index;}}else if(stateLength>previousStateLength){for(var i=0,l=stateLength-previousStateLength;i<l;i++){index++;history.pushState({index:index},'',path);}previousHistoryIndexRef.current=index;}else if(previousStateLength>stateLength){var delta=previousStateLength-stateLength;pendingIndexChangeRef.current=index-delta;history.go(-delta);}});return unsubscribe;});return{getInitialState:getInitialState};}","map":{"version":3,"sources":["useLinking.tsx"],"names":["getStateFromPath","getPathFromState","getStateLength","state","length","focusedState","isUsingLinking","getPathFromStateDefault","React","configRef","getStateFromPathRef","getPathFromStateRef","getInitialState","path","location","previousStateLengthRef","previousHistoryIndexRef","pendingIndexChangeRef","pendingStateUpdateRef","pendingStateMultiUpdateRef","numberOfIndicesAhead","window","navigation","ref","previousHistoryIndex","historyIndex","history","canGoBack","numberOfBacks","index","i","action","getActionFromState","unsubscribe","previousStateLength","stateLength","l","delta"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  getStateFromPath as getStateFromPathDefault,\n  getPathFromState as getPathFromStateDefault,\n  NavigationContainerRef,\n  NavigationState,\n  getActionFromState,\n} from '@react-navigation/core';\nimport { LinkingOptions } from './types';\n\nconst getStateLength = (state: NavigationState) => {\n  let length = 0;\n\n  if (state.history) {\n    length = state.history.length;\n  } else {\n    length = state.index + 1;\n  }\n\n  const focusedState = state.routes[state.index].state;\n\n  if (focusedState && !focusedState.stale) {\n    // If the focused route has history entries, we need to count them as well\n    length += getStateLength(focusedState as NavigationState) - 1;\n  }\n\n  return length;\n};\n\nlet isUsingLinking = false;\n\nexport default function useLinking(\n  ref: React.RefObject<NavigationContainerRef>,\n  {\n    config,\n    getStateFromPath = getStateFromPathDefault,\n    getPathFromState = getPathFromStateDefault,\n  }: LinkingOptions\n) {\n  React.useEffect(() => {\n    if (isUsingLinking) {\n      throw new Error(\n        \"Looks like you are using 'useLinking' in multiple components. This is likely an error since URL integration should only be handled in one place to avoid conflicts. Also ensure that you set your android activity launchMode to single task in your AndroiManifest.xml file.\"\n      );\n    } else {\n      isUsingLinking = true;\n    }\n\n    return () => {\n      isUsingLinking = false;\n    };\n  });\n\n  // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners\n  // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`\n  // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect\n  const configRef = React.useRef(config);\n  const getStateFromPathRef = React.useRef(getStateFromPath);\n  const getPathFromStateRef = React.useRef(getPathFromState);\n\n  React.useEffect(() => {\n    configRef.current = config;\n    getStateFromPathRef.current = getStateFromPath;\n    getPathFromStateRef.current = getPathFromState;\n  }, [config, getPathFromState, getStateFromPath]);\n\n  // Make it an async function to keep consistent with the native impl\n  const getInitialState = React.useCallback(async () => {\n    const path = location.pathname + location.search;\n\n    if (path) {\n      return getStateFromPathRef.current(path, configRef.current);\n    } else {\n      return undefined;\n    }\n  }, []);\n\n  const previousStateLengthRef = React.useRef<number | undefined>(undefined);\n  const previousHistoryIndexRef = React.useRef(0);\n\n  const pendingIndexChangeRef = React.useRef<number | undefined>();\n  const pendingStateUpdateRef = React.useRef<boolean>(false);\n  const pendingStateMultiUpdateRef = React.useRef<boolean>(false);\n\n  // If we're navigating ahead >1, we're not restoring whole state,\n  // but just navigate to the selected route not caring about previous routes\n  // therefore if we need to go back, we need to pop screen and navigate to the new one\n  // Possibly, we will need to reuse the same mechanism.\n  // E.g. if we went ahead+4 (numberOfIndicesAhead = 3), and back-2,\n  // actually we need to pop the screen we navigated\n  // and navigate again, setting numberOfIndicesAhead to 1.\n  const numberOfIndicesAhead = React.useRef(0);\n\n  React.useEffect(() => {\n    window.addEventListener('popstate', () => {\n      const navigation = ref.current;\n\n      if (!navigation) {\n        return;\n      }\n\n      const previousHistoryIndex = previousHistoryIndexRef.current;\n      const historyIndex = history.state?.index ?? 0;\n\n      previousHistoryIndexRef.current = historyIndex;\n\n      if (pendingIndexChangeRef.current === historyIndex) {\n        pendingIndexChangeRef.current = undefined;\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      let canGoBack = true;\n      let numberOfBacks = 0;\n\n      if (previousHistoryIndex === historyIndex) {\n        if (location.pathname + location.search !== path) {\n          pendingStateUpdateRef.current = true;\n          history.replaceState({ index: historyIndex }, '', path);\n        }\n      } else if (previousHistoryIndex > historyIndex) {\n        numberOfBacks =\n          previousHistoryIndex - historyIndex - numberOfIndicesAhead.current;\n\n        if (numberOfBacks > 0) {\n          pendingStateMultiUpdateRef.current = true;\n\n          if (numberOfBacks > 1) {\n            pendingStateMultiUpdateRef.current = true;\n          }\n\n          pendingStateUpdateRef.current = true;\n\n          for (let i = 0; i < numberOfBacks; i++) {\n            navigation.goBack();\n          }\n        } else {\n          canGoBack = false;\n        }\n      }\n\n      if (previousHistoryIndex < historyIndex || !canGoBack) {\n        if (canGoBack) {\n          numberOfIndicesAhead.current =\n            historyIndex - previousHistoryIndex - 1;\n        } else {\n          navigation.goBack();\n          numberOfIndicesAhead.current -= previousHistoryIndex - historyIndex;\n        }\n\n        const state = getStateFromPathRef.current(\n          location.pathname + location.search,\n          configRef.current\n        );\n\n        pendingStateMultiUpdateRef.current = true;\n\n        if (state) {\n          const action = getActionFromState(state);\n\n          pendingStateUpdateRef.current = true;\n\n          if (action !== undefined) {\n            navigation.dispatch(action);\n          } else {\n            navigation.resetRoot(state);\n          }\n        }\n      }\n    });\n  }, [ref]);\n\n  React.useEffect(() => {\n    if (ref.current && previousStateLengthRef.current === undefined) {\n      previousStateLengthRef.current = getStateLength(\n        ref.current.getRootState()\n      );\n    }\n\n    if (ref.current && location.pathname + location.search === '/') {\n      history.replaceState(\n        { index: history.state?.index ?? 0 },\n        '',\n        getPathFromStateRef.current(\n          ref.current.getRootState(),\n          configRef.current\n        )\n      );\n    }\n\n    const unsubscribe = ref.current?.addListener('state', () => {\n      const navigation = ref.current;\n\n      if (!navigation) {\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      const previousStateLength = previousStateLengthRef.current ?? 1;\n      const stateLength = getStateLength(state);\n\n      if (pendingStateMultiUpdateRef.current) {\n        if (location.pathname + location.search === path) {\n          pendingStateMultiUpdateRef.current = false;\n        } else {\n          return;\n        }\n      }\n\n      previousStateLengthRef.current = stateLength;\n\n      if (\n        pendingStateUpdateRef.current &&\n        location.pathname + location.search === path\n      ) {\n        pendingStateUpdateRef.current = false;\n        return;\n      }\n\n      let index = history.state?.index ?? 0;\n\n      if (previousStateLength === stateLength) {\n        // If no new enrties were added to history in our navigation state, we want to replaceState\n        if (location.pathname + location.search !== path) {\n          history.replaceState({ index }, '', path);\n          previousHistoryIndexRef.current = index;\n        }\n      } else if (stateLength > previousStateLength) {\n        // If new enrties were added, pushState until we have same length\n        // This won't be accurate if multiple enrties were added at once, but that's the best we can do\n        for (let i = 0, l = stateLength - previousStateLength; i < l; i++) {\n          index++;\n          history.pushState({ index }, '', path);\n        }\n\n        previousHistoryIndexRef.current = index;\n      } else if (previousStateLength > stateLength) {\n        const delta = previousStateLength - stateLength;\n\n        // We need to set this to ignore the `popstate` event\n        pendingIndexChangeRef.current = index - delta;\n\n        // If new enrties were removed, go back so that we have same length\n        history.go(-delta);\n      }\n    });\n\n    return unsubscribe;\n  });\n\n  return {\n    getInitialState,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}