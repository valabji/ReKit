{"ast":null,"code":"import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import queryString from'query-string';export default function getPathFromState(state){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(state===undefined){throw Error('NavigationState not passed');}var path='/';var current=state;while(current){var index=typeof current.index==='number'?current.index:0;var route=current.routes[index];var currentOptions=options;var pattern=route.name;while(route.name in currentOptions){if(typeof currentOptions[route.name]==='string'){pattern=currentOptions[route.name];break;}else if(typeof currentOptions[route.name]==='object'){if(!currentOptions[route.name].screens){pattern=currentOptions[route.name].path;break;}else{if(route.state===undefined){pattern=currentOptions[route.name].path;break;}else{index=typeof route.state.index==='number'?route.state.index:0;var nextRoute=route.state.routes[index];var deeperConfig=currentOptions[route.name].screens;if(nextRoute.name in deeperConfig){route=nextRoute;currentOptions=deeperConfig;}else{pattern=currentOptions[route.name].path;break;}}}}}if(pattern!==''){(function(){var config=currentOptions[route.name]!==undefined?currentOptions[route.name].stringify:undefined;var params=route.params?Object.entries(route.params).reduce(function(acc,_ref){var _ref2=_slicedToArray(_ref,2),key=_ref2[0],value=_ref2[1];acc[key]=(config===null||config===void 0?void 0:config[key])?config[key](value):String(value);return acc;},{}):undefined;if(currentOptions[route.name]!==undefined){path+=pattern.split('/').map(function(p){var name=p.replace(/^:/,'');if(params&&name in params&&p.startsWith(':')){var value=params[name];delete params[name];return encodeURIComponent(value);}return encodeURIComponent(p);}).join('/');}else{path+=encodeURIComponent(route.name);}if(route.state){path+='/';}else if(params){var query=queryString.stringify(params);if(query){path+=\"?\".concat(query);}}})();}current=route.state;}path=path!=='/'&&path.slice(path.length-1)==='/'?path.slice(0,-1):path;return path;}","map":{"version":3,"sources":["getPathFromState.tsx"],"names":["options","state","Error","path","current","index","route","currentOptions","pattern","nextRoute","deeperConfig","config","params","Object","acc","String","p","name","value","encodeURIComponent","query","queryString"],"mappings":"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","sourcesContent":["import queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype Options = {\n  [routeName: string]:\n    | string\n    | {\n        path?: string;\n        stringify?: StringifyConfig;\n        screens?: Options;\n      };\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * Example:\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       stringify: { author: author => author.toLowerCase() }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState(\n  state?: State,\n  options: Options = {}\n): string {\n  if (state === undefined) {\n    throw Error('NavigationState not passed');\n  }\n  let path = '/';\n\n  let current: State | undefined = state;\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n    let currentOptions = options;\n    let pattern = route.name;\n\n    while (route.name in currentOptions) {\n      if (typeof currentOptions[route.name] === 'string') {\n        pattern = currentOptions[route.name] as string;\n        break;\n      } else if (typeof currentOptions[route.name] === 'object') {\n        // if there is no `screens` property, we return pattern\n        if (\n          !(currentOptions[route.name] as {\n            screens: Options;\n          }).screens\n        ) {\n          pattern = (currentOptions[route.name] as { path: string }).path;\n          break;\n        } else {\n          // if it is the end of state, we return pattern\n          if (route.state === undefined) {\n            pattern = (currentOptions[route.name] as { path: string }).path;\n            break;\n          } else {\n            index =\n              typeof route.state.index === 'number' ? route.state.index : 0;\n            const nextRoute = route.state.routes[index];\n            const deeperConfig = (currentOptions[route.name] as {\n              screens: Options;\n            }).screens;\n            // if there is config for next route name, we go deeper\n            if (nextRoute.name in deeperConfig) {\n              route = nextRoute as Route<string> & { state?: State };\n              currentOptions = deeperConfig;\n            } else {\n              // if not, there is no sense in going deeper in config\n              pattern = (currentOptions[route.name] as { path: string }).path;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // we don't add empty path strings to path\n    if (pattern !== '') {\n      const config =\n        currentOptions[route.name] !== undefined\n          ? (currentOptions[route.name] as { stringify?: StringifyConfig })\n              .stringify\n          : undefined;\n\n      const params = route.params\n        ? // Stringify all of the param values before we use them\n          Object.entries(route.params).reduce<{\n            [key: string]: string;\n          }>((acc, [key, value]) => {\n            acc[key] = config?.[key] ? config[key](value) : String(value);\n            return acc;\n          }, {})\n        : undefined;\n\n      if (currentOptions[route.name] !== undefined) {\n        path += pattern\n          .split('/')\n          .map((p) => {\n            const name = p.replace(/^:/, '');\n\n            // If the path has a pattern for a param, put the param in the path\n            if (params && name in params && p.startsWith(':')) {\n              const value = params[name];\n              // Remove the used value from the params object since we'll use the rest for query string\n              // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n              delete params[name];\n              return encodeURIComponent(value);\n            }\n\n            return encodeURIComponent(p);\n          })\n          .join('/');\n      } else {\n        path += encodeURIComponent(route.name);\n      }\n\n      if (route.state) {\n        path += '/';\n      } else if (params) {\n        const query = queryString.stringify(params);\n\n        if (query) {\n          path += `?${query}`;\n        }\n      }\n    }\n\n    current = route.state;\n  }\n\n  path =\n    path !== '/' && path.slice(path.length - 1) === '/'\n      ? path.slice(0, -1)\n      : path;\n\n  return path;\n}\n"]},"metadata":{},"sourceType":"module"}