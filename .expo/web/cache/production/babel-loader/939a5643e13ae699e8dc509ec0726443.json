{"ast":null,"code":"import _toConsumableArray from\"@babel/runtime/helpers/toConsumableArray\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import escape from'escape-string-regexp';import queryString from'query-string';export default function getStateFromPath(path){var _ref;var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(path===''){return undefined;}var initialRoutes=[];var configs=(_ref=[]).concat.apply(_ref,_toConsumableArray(Object.keys(options).map(function(key){return createNormalizedConfigs(key,options,[],initialRoutes);})));var result;var current;var remaining=path.replace(/[/]+/,'/').replace(/^\\//,'').replace(/\\?.*/,'');while(remaining){var routeNames=void 0;var params=void 0;var _loop=function _loop(config){var match=remaining.match(config.match);if(match){routeNames=_toConsumableArray(config.routeNames);var paramPatterns=config.pattern.split('/').filter(function(p){return p.startsWith(':');});if(paramPatterns.length){params=paramPatterns.reduce(function(acc,p,i){var key=p.replace(/^:/,'');var value=match[i+1];acc[key]=config.parse&&config.parse[key]?config.parse[key](value):value;return acc;},{});}remaining=remaining.replace(match[0],'');return\"break\";}};for(var _iterator=configs,_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[typeof Symbol===\"function\"?Symbol.iterator:\"@@iterator\"]();;){var _ref2;if(_isArray){if(_i>=_iterator.length)break;_ref2=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref2=_i.value;}var config=_ref2;var _ret=_loop(config);if(_ret===\"break\")break;}if(routeNames===undefined){var segments=remaining.split('/');routeNames=[decodeURIComponent(segments[0])];segments.shift();remaining=segments.join('/');}var state=void 0;var routeName=routeNames.shift();var initialRoute=findInitialRoute(routeName,initialRoutes);state=createNestedState(initialRoute,routeName,routeNames.length===0,params);if(routeNames.length>0){var nestedState=state;while(routeName=routeNames.shift()){initialRoute=findInitialRoute(routeName,initialRoutes);nestedState.routes[nestedState.index||0].state=createNestedState(initialRoute,routeName,routeNames.length===0,params);if(routeNames.length>0){nestedState=nestedState.routes[nestedState.index||0].state;}}}if(current){var _current2;while((_current=current)===null||_current===void 0?void 0:_current.routes[current.index||0].state){var _current;current=current.routes[current.index||0].state;}current.routes[((_current2=current)===null||_current2===void 0?void 0:_current2.index)||0].state=state;}else{result=state;}current=state;}if(current==null||result==null){return undefined;}var query=path.split('?')[1];if(query){var _current4;while((_current3=current)===null||_current3===void 0?void 0:_current3.routes[current.index||0].state){var _current3;current=current.routes[current.index||0].state;}var route=current.routes[((_current4=current)===null||_current4===void 0?void 0:_current4.index)||0];var _params=queryString.parse(query);var parseFunction=findParseConfigForRoute(route.name,configs);if(parseFunction){Object.keys(_params).forEach(function(name){if(parseFunction[name]&&typeof _params[name]==='string'){_params[name]=parseFunction[name](_params[name]);}});}route.params=_objectSpread({},route.params,{},_params);}return result;}function createNormalizedConfigs(key,routeConfig){var routeNames=arguments.length>2&&arguments[2]!==undefined?arguments[2]:[];var initials=arguments.length>3?arguments[3]:undefined;var configs=[];routeNames.push(key);var value=routeConfig[key];if(typeof value==='string'){if(value!==''){configs.push(createConfigItem(routeNames,value));}}else if(typeof value==='object'){if(value.path&&value.path!==''){configs.push(createConfigItem(routeNames,value.path,value.parse));}if(value.screens){if(value.initialRouteName){initials.push({initialRouteName:value.initialRouteName,connectedRoutes:Object.keys(value.screens)});}Object.keys(value.screens).forEach(function(nestedConfig){var result=createNormalizedConfigs(nestedConfig,value.screens,routeNames,initials);configs.push.apply(configs,_toConsumableArray(result));});}}routeNames.pop();return configs;}function createConfigItem(routeNames,pattern,parse){var match=new RegExp('^'+escape(pattern).replace(/:[a-z0-9]+/gi,'([^/]+)')+'/?');return{match:match,pattern:pattern,routeNames:_toConsumableArray(routeNames),parse:parse};}function findParseConfigForRoute(routeName,flatConfig){for(var _iterator2=flatConfig,_isArray2=Array.isArray(_iterator2),_i2=0,_iterator2=_isArray2?_iterator2:_iterator2[typeof Symbol===\"function\"?Symbol.iterator:\"@@iterator\"]();;){var _ref3;if(_isArray2){if(_i2>=_iterator2.length)break;_ref3=_iterator2[_i2++];}else{_i2=_iterator2.next();if(_i2.done)break;_ref3=_i2.value;}var _config=_ref3;if(routeName===_config.routeNames[_config.routeNames.length-1]){return _config.parse;}}return undefined;}function findInitialRoute(routeName,initialRoutes){for(var _iterator3=initialRoutes,_isArray3=Array.isArray(_iterator3),_i3=0,_iterator3=_isArray3?_iterator3:_iterator3[typeof Symbol===\"function\"?Symbol.iterator:\"@@iterator\"]();;){var _ref4;if(_isArray3){if(_i3>=_iterator3.length)break;_ref4=_iterator3[_i3++];}else{_i3=_iterator3.next();if(_i3.done)break;_ref4=_i3.value;}var _config2=_ref4;if(_config2.connectedRoutes.includes(routeName)){return _config2.initialRouteName===routeName?undefined:_config2.initialRouteName;}}return undefined;}function createNestedState(initialRoute,routeName,isEmpty,params){if(isEmpty){if(initialRoute){return{index:1,routes:[{name:initialRoute},_objectSpread({name:routeName},params&&{params:params})]};}else{return{routes:[_objectSpread({name:routeName},params&&{params:params})]};}}else{if(initialRoute){return{index:1,routes:[{name:initialRoute},{name:routeName,state:{routes:[]}}]};}else{return{routes:[{name:routeName,state:{routes:[]}}]};}}}","map":{"version":3,"sources":["getStateFromPath.tsx"],"names":["options","path","initialRoutes","configs","Object","key","createNormalizedConfigs","remaining","routeNames","params","match","config","paramPatterns","p","value","i","acc","segments","decodeURIComponent","state","routeName","initialRoute","findInitialRoute","createNestedState","nestedState","current","result","query","route","queryString","parseFunction","findParseConfigForRoute","name","routeConfig","createConfigItem","initials","initialRouteName","connectedRoutes","nestedConfig","escape","pattern","parse","index","routes"],"mappings":"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","sourcesContent":["import escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  InitialState,\n} from '@react-navigation/routers';\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype Options = {\n  [routeName: string]:\n    | string\n    | {\n        path?: string;\n        parse?: ParseConfig;\n        screens?: Options;\n        initialRouteName?: string;\n      };\n};\n\ntype RouteConfig = {\n  match: RegExp;\n  pattern: string;\n  routeNames: string[];\n  parse: ParseConfig | undefined;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  connectedRoutes: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       parse: { id: Number }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(\n  path: string,\n  options: Options = {}\n): ResultState | undefined {\n  if (path === '') {\n    return undefined;\n  }\n  let initialRoutes: InitialRouteConfig[] = [];\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[]).concat(\n    ...Object.keys(options).map((key) =>\n      createNormalizedConfigs(key, options, [], initialRoutes)\n    )\n  );\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  let remaining = path\n    .replace(/[/]+/, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*/, ''); // Remove query params which we will handle later\n\n  while (remaining) {\n    let routeNames: string[] | undefined;\n    let params: Record<string, any> | undefined;\n\n    // Go through all configs, and see if the next path segment matches our regex\n    for (const config of configs) {\n      const match = remaining.match(config.match);\n\n      // If our regex matches, we need to extract params from the path\n      if (match) {\n        routeNames = [...config.routeNames];\n\n        const paramPatterns = config.pattern\n          .split('/')\n          .filter((p) => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\n            const key = p.replace(/^:/, '');\n            const value = match[i + 1]; // The param segments start from index 1 in the regex match result\n\n            acc[key] =\n              config.parse && config.parse[key]\n                ? config.parse[key](value)\n                : value;\n\n            return acc;\n          }, {});\n        }\n\n        // Remove the matched segment from the remaining path\n        remaining = remaining.replace(match[0], '');\n\n        break;\n      }\n    }\n\n    // If we hadn't matched any segments earlier, use the path as route name\n    if (routeNames === undefined) {\n      const segments = remaining.split('/');\n\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    let state: InitialState;\n    let routeName = routeNames.shift() as string;\n    let initialRoute = findInitialRoute(routeName, initialRoutes);\n\n    state = createNestedState(\n      initialRoute,\n      routeName,\n      routeNames.length === 0,\n      params\n    );\n\n    if (routeNames.length > 0) {\n      let nestedState = state;\n\n      while ((routeName = routeNames.shift() as string)) {\n        initialRoute = findInitialRoute(routeName, initialRoutes);\n        nestedState.routes[nestedState.index || 0].state = createNestedState(\n          initialRoute,\n          routeName,\n          routeNames.length === 0,\n          params\n        );\n        if (routeNames.length > 0) {\n          nestedState = nestedState.routes[nestedState.index || 0]\n            .state as InitialState;\n        }\n      }\n    }\n\n    if (current) {\n      // The state should be nested inside the deepest route we parsed before\n      while (current?.routes[current.index || 0].state) {\n        current = current.routes[current.index || 0].state;\n      }\n\n      (current as PartialState<NavigationState>).routes[\n        current?.index || 0\n      ].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const query = path.split('?')[1];\n\n  if (query) {\n    while (current?.routes[current.index || 0].state) {\n      // The query params apply to the deepest route\n      current = current.routes[current.index || 0].state;\n    }\n\n    const route = (current as PartialState<NavigationState>).routes[\n      current?.index || 0\n    ];\n\n    const params = queryString.parse(query);\n    const parseFunction = findParseConfigForRoute(route.name, configs);\n\n    if (parseFunction) {\n      Object.keys(params).forEach((name) => {\n        if (parseFunction[name] && typeof params[name] === 'string') {\n          params[name] = parseFunction[name](params[name] as string);\n        }\n      });\n    }\n\n    route.params = { ...route.params, ...params };\n  }\n\n  return result;\n}\n\nfunction createNormalizedConfigs(\n  key: string,\n  routeConfig: Options,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[]\n): RouteConfig[] {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(key);\n\n  const value = routeConfig[key];\n\n  if (typeof value === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    if (value !== '') {\n      configs.push(createConfigItem(routeNames, value));\n    }\n  } else if (typeof value === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (value.path && value.path !== '') {\n      configs.push(createConfigItem(routeNames, value.path, value.parse));\n    }\n    if (value.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (value.initialRouteName) {\n        initials.push({\n          initialRouteName: value.initialRouteName,\n          connectedRoutes: Object.keys(value.screens),\n        });\n      }\n      Object.keys(value.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          value.screens as Options,\n          routeNames,\n          initials\n        );\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n}\n\nfunction createConfigItem(\n  routeNames: string[],\n  pattern: string,\n  parse?: ParseConfig\n): RouteConfig {\n  const match = new RegExp(\n    '^' + escape(pattern).replace(/:[a-z0-9]+/gi, '([^/]+)') + '/?'\n  );\n\n  return {\n    match,\n    pattern,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n  };\n}\n\nfunction findParseConfigForRoute(\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n  return undefined;\n}\n\n// tries to find an initial route connected with the one passed\nfunction findInitialRoute(\n  routeName: string,\n  initialRoutes: InitialRouteConfig[]\n): string | undefined {\n  for (const config of initialRoutes) {\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName\n        ? undefined\n        : config.initialRouteName;\n    }\n  }\n  return undefined;\n}\n\n// returns nested state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nfunction createNestedState(\n  initialRoute: string | undefined,\n  routeName: string,\n  isEmpty: boolean,\n  params?: Record<string, any> | undefined\n): InitialState {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, ...(params && { params }) },\n        ],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, ...(params && { params }) }],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, state: { routes: [] } },\n        ],\n      };\n    } else {\n      return { routes: [{ name: routeName as string, state: { routes: [] } }] };\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}